<!-- 此文件由机器翻译自 SKILL.md -->

---
名称：XLSX
描述：“电子表格工具包 (.xlsx/.csv)。使用公式/格式创建/编辑、分析数据、可视化、重新计算公式，以进行电子表格处理和分析。”
许可证：专有。 LICENSE.txt 有完整的条款
---

# 输出要求

## 所有 Excel 文件

### 零公式错误
- 每个 Excel 模型必须提供零公式错误（#REF!、#DIV/0!、#VALUE!、#N/A、#NAME？）

### 保留现有模板（更新模板时）
- 修改文件时研究并完全匹配现有格式、样式和约定
- 切勿对具有既定模式的文件强加标准化格式
- 现有的模板约定始终优先于这些准则

## 财务模型

### 颜色编码标准
除非用户或现有模板另有说明

#### 行业标准颜色约定
- **蓝色文本（RGB：0,0,255）**：硬编码输入，用户将根据场景更改数字
- **黑色文本（RGB：0,0,0）**：所有公式和计算
- **绿色文本（RGB：0,128,0）**：从同一工作簿中的其他工作表中提取的链接
- **红色文本（RGB：255,0,0）**：其他文件的外部链接
- **黄色背景（RGB：255,255,0）**：需要注意的关键假设或需要更新的单元格

### 数字格式标准

#### 所需格式规则
- **年**：格式为文本字符串（例如，“2024”而不是“2,024”）
- **货币**：使用$#,##0格式；始终在标题中指定单位（“收入 ($mm)”）
- **零**：使用数字格式将所有零设为“-”，包括百分比（例如“$#,##0;($#,##0);-”）
- **百分比**：默认为 0.0% 格式（一位小数）
- **倍数**：估值倍数格式为 0.0x（EV/EBITDA、P/E）
- **负数**：使用括号 (123)，而不是负 -123

### 公式构建规则

#### 假设放置
- 将所有假设（增长率、利润率、倍数等）放在单独的假设单元格中
- 在公式中使用单元格引用而不是硬编码值
- 示例：使用 =B5*(1+$B$6) 代替 =B5*1.05

#### 公式错误预防
- 验证所有单元格引用是否正确
- 检查范围内的差一错误
- 确保所有预测期间的公式一致
- 使用边缘情况进行测试（零值、负数）
- 验证没有意外的循环引用

#### 硬编码的文档要求
- 评论或在旁边的单元格中（如果在表格末尾）。格式：“来源：[系统/文档]、[日期]、[具体参考]、[URL（如果适用）”
- 示例：
  - “资料来源：公司 10-K，2024 财年，第 45 页，收入说明，[SEC EDGAR URL]”
  - “来源：公司 10-Q，2025 年第 2 季度，图表 99.1，[SEC EDGAR URL]”
  - “资料来源：彭博终端，2025 年 8 月 15 日，AAPL 美国股票”
  - “来源：FactSet，2025 年 8 月 20 日，共识估计屏幕”

# XLSX 创建、编辑和分析

## 概述

使用公式、格式设置和数据分析创建、编辑或分析 Excel 电子表格。使用 openpyxl 和 pandas 将此技能应用于电子表格处理。重新计算公式并确保出版质量输出的零错误。

## 重要要求

**公式重新计算需要 LibreOffice**：您可以假设安装了 LibreOffice，以便使用 `recalc.py` 脚本重新计算公式值。该脚本会在首次运行时自动配置 LibreOffice

## 读取和分析数据

### 使用 pandas 进行数据分析
对于数据分析、可视化和基本操作，可以使用**pandas**，它提供了强大的数据操作能力：

```python
import pandas as pd

# Read Excel
df = pd.read_excel('file.xlsx')  # Default: first sheet
all_sheets = pd.read_excel('file.xlsx', sheet_name=None)  # All sheets as dict

# Analyze
df.head()      # Preview data
df.info()      # Column info
df.describe()  # Statistics

# Write Excel
df.to_excel('output.xlsx', index=False)
```

## Excel 文件工作流程

## 关键：使用公式，而不是硬编码值

**始终使用 Excel 公式，而不是在 Python 中计算值并对它们进行硬编码。** 这可确保电子表格保持动态和可更新。

### ❌错误 - 硬编码计算值
<<<代码块_1>>>

### ✅ 正确 - 使用 Excel 公式
<<<代码块_2>>>

这适用于所有计算 - 总计、百分比、比率、差异等。当源数据发生变化时，电子表格应该能够重新计算。

## 通用工作流程
1. **选择工具**：pandas 用于数据，openpyxl 用于公式/格式
2. **创建/加载**：创建新工作簿或加载现有文件
3. **修改**：添加/编辑数据、公式和格式
4. **保存**：写入文件
5. **重新计算公式（如果使用公式则必须）**：使用 recalc.py 脚本
   <<<代码块_3>>>
6. **验证并修复任何错误**： 
   - 脚本返回带有错误详细信息的 JSON
- 如果 `status` 是 `errors_found`，请检查 `error_summary` 的特定错误类型和位置
   - 修复发现的错误并再次重新计算
   - 需要修复的常见错误：
     - `#REF!`：无效的单元格引用
     - `#DIV/0!`：除以零
     - `#VALUE!`：公式中的数据类型错误
     - `#NAME?`：无法识别的公式名称

### 创建新的 Excel 文件

<<<代码块_4>>>

### 编辑现有 Excel 文件

<<<代码块_5>>>

## 重新计算公式

由 openpyxl 创建或修改的 Excel 文件包含字符串形式的公式，但不包含计算值。使用提供的 `recalc.py` 脚本重新计算公式：

<<<代码块_6>>>

示例：
```bash
python recalc.py output.xlsx 30
```

脚本：
- 首次运行时自动设置 LibreOffice 宏
- 重新计算所有工作表中的所有公式
- 扫描所有单元格中的 Excel 错误（#REF!、#DIV/0! 等）
- 返回包含详细错误位置和计数的 JSON
- 适用于 Linux 和 macOS

## 配方验证清单

快速检查以确保公式正确运行：

### 基本验证
- [ ] **测试 2-3 个示例参考**：在构建完整模型之前验证它们提取正确的值
- [ ] **列映射**：确认 Excel 列匹配（例如，第 64 列 = BL，而不是 BK）
- [ ] **行偏移**：记住 Excel 行是 1 索引的（DataFrame 第 5 行 = Excel 第 6 行）

### 常见陷阱
- [ ] **NaN 处理**：使用 `pd.notna()` 检查空值
- [ ] **最右列**：FY 数据通常位于第 50 列以上 
- [ ] **多个匹配**：搜索所有出现的情况，而不仅仅是第一个
- [ ] **除以零**：在公式中使用 `/` 之前检查分母 (#DIV/0!)
- [ ] **错误引用**：验证所有单元格引用都指向预期单元格（#REF！）
- [ ] **跨工作表引用**：使用正确的格式（Sheet1！A1）来链接工作表

### 配方测试策略
- [ ] **从小处开始**：在广泛应用之前在 2-3 个单元格上测试公式
- [ ] **验证依赖关系**：检查公式中引用的所有单元格是否存在
- [ ] **测试边缘情况**：包括零、负和非常大的值

### 解释 recalc.py 输出
该脚本返回带有错误详细信息的 JSON：
```json
{
  "status": "success",           // or "errors_found"
  "total_errors": 0,              // Total error count
  "total_formulas": 42,           // Number of formulas in file
  "error_summary": {              // Only present if errors found
    "#REF!": {
      "count": 2,
      "locations": ["Sheet1!B5", "Sheet1!C10"]
    }
  }
}
```

## 最佳实践

### 库选择
- **pandas**：最适合数据分析、批量操作和简单数据导出
- **openpyxl**：最适合复杂的格式设置、公式和 Excel 特定功能

### 使用 openpyxl
- 单元格索引从 1 开始（行=1，列=1 指单元格 A1）
- 使用`data_only=True`读取计算值：`load_workbook('file.xlsx', data_only=True)`
- **警告**：如果使用 `data_only=True` 打开并保存，公式将被值替换并永久丢失
- 对于大文件：使用 `read_only=True` 进行读取或 `write_only=True` 进行写入
- 公式被保留但不被评估 - 使用 recalc.py 更新值

### 使用 pandas
- 指定数据类型以避免推理问题：`pd.read_excel('file.xlsx', dtype={'id': str})`
- 对于大文件，读取特定列：`pd.read_excel('file.xlsx', usecols=['A', 'C', 'E'])`
- 正确处理日期：`pd.read_excel('file.xlsx', parse_dates=['date_column'])`

## 代码风格指南
**重要**：为 Excel 操作生成 Python 代码时：
- 编写最少、简洁的 Python 代码，没有不必要的注释
- 避免冗长的变量名称和冗余操作
- 避免不必要的打印语句

**对于 Excel 文件本身**：
- 向具有复杂公式或重要假设的单元格添加注释
- 记录硬编码值的数据源
- 包括关键计算和模型部分的注释